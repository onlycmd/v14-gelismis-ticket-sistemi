const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');
const fs = require('fs');
const Ticket = require('../models/Ticket');
const GuildConfig = require('../models/GuildConfig');
const config = require('../config');

class TicketManager {
    constructor(client) {
        this.client = client;
        this.cooldowns = new Map();
    }

    // MongoDB'den config verilerini al
    async getGuildConfig(guildId) {
        try {
            const guildConfig = await GuildConfig.getConfig(guildId);
            if (guildConfig) {
                return {
                    ticketCategoryId: guildConfig.ticketCategoryId,
                    closedCategoryId: guildConfig.closedCategoryId,
                    logChannelId: guildConfig.logChannelId,
                    supportRoleId: guildConfig.supportRoleId,
                    adminRoleId: guildConfig.adminRoleId,
                    incomingCategoryId: guildConfig.incomingCategoryId
                };
            }
            // Eƒüer MongoDB'de config yoksa, varsayƒ±lan config'i kullan
            return {
                ticketCategoryId: config.ticketCategoryId,
                closedCategoryId: config.closedTicketCategoryId,
                logChannelId: config.logChannelId,
                supportRoleId: config.supportRoleId,
                adminRoleId: config.adminRoleId,
                incomingCategoryId: config.incomingCategoryId
            };
        } catch (error) {
            console.error('Config alma hatasƒ±:', error);
            // Hata durumunda varsayƒ±lan config'i kullan
            return {
                ticketCategoryId: config.ticketCategoryId,
                closedCategoryId: config.closedTicketCategoryId,
                logChannelId: config.logChannelId,
                supportRoleId: config.supportRoleId,
                adminRoleId: config.adminRoleId,
                incomingCategoryId: config.incomingCategoryId
            };
        }
    }

    // Ticket ID olu≈üturma
    generateTicketId() {
        return `TICKET-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;
    }

    // Cooldown kontrol√º
    isOnCooldown(userId) {
        const cooldown = this.cooldowns.get(userId);
        if (!cooldown) return false;
        
        if (Date.now() - cooldown < config.ticketCooldown) {
            return true;
        }
        
        this.cooldowns.delete(userId);
        return false;
    }

    // Cooldown ekleme
    addCooldown(userId) {
        this.cooldowns.set(userId, Date.now());
    }

    // Otomatik atama - √∂nce support ve admin, sonra aktif olanlarƒ± bul
    async findAvailableSupport(guild, guildConfig) {
        try {
            const supportRole = guild.roles.cache.get(guildConfig.supportRoleId);
            const adminRole = guild.roles.cache.get(guildConfig.adminRoleId);
            
            if (!supportRole && !adminRole) return null;

            // √ñnce support ve admin rollerini kontrol et
            const supportMembers = supportRole ? supportRole.members : new Map();
            const adminMembers = adminRole ? adminRole.members : new Map();
            
            // Hem support hem admin rol√ºne sahip olanlarƒ± bul
            const availableMembers = [];
            
            // Support √ºyelerini ekle (sadece online olanlar)
            for (const [memberId, member] of supportMembers) {
                // Online durumunu kontrol et
                const presence = guild.presences.cache.get(memberId);
                const isOnline = presence && (presence.status === 'online' || presence.status === 'idle' || presence.status === 'dnd');
                
                if (!isOnline) continue; // Offline olanlarƒ± atla
                
                const isAdmin = adminMembers.has(memberId);
                const openTickets = await Ticket.countDocuments({ 
                    assignedTo: memberId, 
                    status: 'a√ßƒ±k' 
                });
                
                availableMembers.push({
                    member,
                    workload: openTickets,
                    isAdmin: isAdmin,
                    priority: isAdmin ? 1 : 2 // Admin'ler √∂ncelikli
                });
            }
            
            // Sadece admin rol√ºne sahip olanlarƒ± ekle (support yoksa, sadece online olanlar)
            for (const [memberId, member] of adminMembers) {
                if (!supportMembers.has(memberId)) {
                    // Online durumunu kontrol et
                    const presence = guild.presences.cache.get(memberId);
                    const isOnline = presence && (presence.status === 'online' || presence.status === 'idle' || presence.status === 'dnd');
                    
                    if (!isOnline) continue; // Offline olanlarƒ± atla
                    
                    const openTickets = await Ticket.countDocuments({ 
                        assignedTo: memberId, 
                        status: 'a√ßƒ±k' 
                    });
                    
                    availableMembers.push({
                        member,
                        workload: openTickets,
                        isAdmin: true,
                        priority: 1
                    });
                }
            }

            if (availableMembers.length === 0) return null;

            // √ñnce √∂nceliƒüe g√∂re, sonra i≈ü y√ºk√ºne g√∂re sƒ±rala
            availableMembers.sort((a, b) => {
                if (a.priority !== b.priority) {
                    return a.priority - b.priority; // Admin'ler √∂nce
                }
                return a.workload - b.workload; // Sonra i≈ü y√ºk√º
            });

            return availableMembers[0].member;

        } catch (error) {
            console.error('Otomatik atama hatasƒ±:', error);
            return null;
        }
    }

    // Ticket a√ßma
    async createTicket(interaction, type) {
        const userId = interaction.user.id;
        const guild = interaction.guild;

        // MongoDB'den config verilerini al
        const guildConfig = await this.getGuildConfig(guild.id);

        // Cooldown kontrol√º
        if (this.isOnCooldown(userId)) {
            const remaining = Math.ceil((config.ticketCooldown - (Date.now() - this.cooldowns.get(userId))) / 1000);
            return {
                success: false,
                message: `‚è∞ L√ºtfen ${remaining} saniye bekleyin!`
            };
        }

        // A√ßƒ±k ticket kontrol√º
        const openTickets = await Ticket.getOpenTicketsByUser(userId);
        if (openTickets.length >= config.maxTicketsPerUser) {
            return {
                success: false,
                message: `‚ùå Zaten ${config.maxTicketsPerUser} a√ßƒ±k ticket'ƒ±nƒ±z var!`
            };
        }

        try {
            const ticketId = this.generateTicketId();
            const channelName = `ticket-${interaction.user.username}`;
            
            // Kategori kontrol√º - √∂nce incomingCategoryId'yi dene, yoksa ticketCategoryId'yi kullan
            let category = null;
            if (guildConfig.incomingCategoryId) {
                category = guild.channels.cache.get(guildConfig.incomingCategoryId);
            }
            if (!category && guildConfig.ticketCategoryId) {
                category = guild.channels.cache.get(guildConfig.ticketCategoryId);
            }
            if (!category) {
                return {
                    success: false,
                    message: '‚ùå Ticket kategorisi bulunamadƒ±! L√ºtfen √∂nce `/setup` komutunu kullanƒ±n.'
                };
            }

            // Otomatik atama yap
            const assignedSupport = await this.findAvailableSupport(guild, guildConfig);
            let assignedUserId = null;
            let assignedUser = null;
            
            if (assignedSupport) {
                assignedUserId = assignedSupport.id;
                assignedUser = assignedSupport;
            }

            // Kanal olu≈üturma
            const channel = await guild.channels.create({
                name: channelName,
                type: 0, // Text channel
                parent: category,
                permissionOverwrites: [
                    {
                        id: guild.id,
                        deny: [PermissionFlagsBits.ViewChannel]
                    },
                    {
                        id: userId,
                        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ReadMessageHistory],
                        deny: [PermissionFlagsBits.SendMessages] // Ticket a√ßan kullanƒ±cƒ± yazamaz
                    },
                    {
                        id: guildConfig.supportRoleId,
                        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.ReadMessageHistory]
                    },
                    {
                        id: guildConfig.adminRoleId,
                        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.ReadMessageHistory, PermissionFlagsBits.ManageChannels]
                    }
                ]
            });

            // Ticket veritabanƒ±na kaydetme
            const ticket = new Ticket({
                ticketId,
                channelId: channel.id,
                userId,
                type,
                assignedTo: assignedUserId
            });
            await ticket.save();

            // Ho≈ü geldin embed'ƒ±
            const welcomeEmbed = new EmbedBuilder()
                .setTitle(`üé´ Ticket #${ticketId}`)
                .setDescription(`${config.welcomeMessages[type]}

**Ticket Detaylarƒ±:**
‚Ä¢ **Kullanƒ±cƒ±:** <@${userId}>
‚Ä¢ **Tip:** ${config.ticketTypes[type].name}
‚Ä¢ **Olu≈üturulma:** <t:${Math.floor(Date.now() / 1000)}:F>
${assignedUser ? `‚Ä¢ **Atanan Yetkili:** <@${assignedUser.id}>` : '‚Ä¢ **Atanan Yetkili:** ≈ûu anda atama bekleniyor.'}

Ticket'ƒ±nƒ±z ba≈üarƒ±yla olu≈üturuldu! Support ekibimiz en kƒ±sa s√ºrede size yardƒ±mcƒ± olacaktƒ±r.`)
                .setColor(0x36393F)
                .setFooter({ text: 'Ticket Sistemi' });

            welcomeEmbed.setFooter({ text: 'Ticket y√∂netimi i√ßin a≈üaƒüƒ±daki butonlarƒ± kullanƒ±n' });

            // T√ºm y√∂netim butonlarƒ±
            const managementButtons1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('close_ticket')
                        .setLabel('Kapat')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('üîí'),
                    new ButtonBuilder()
                        .setCustomId('transfer_ticket')
                        .setLabel('Ba≈üka Birine Aktar')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üîÑ')
                );

            const managementButtons2 = new ActionRowBuilder()
                .addComponents(); // Artƒ±k ikinci satƒ±rda buton yok

            await channel.send({ 
                embeds: [welcomeEmbed], 
                components: [managementButtons1, managementButtons2] 
            });

            // Eƒüer otomatik atama yapƒ±ldƒ±ysa bildirim g√∂nder ve yazma yetkisi a√ß
            if (assignedUser) {
                // Atama bildirimi
                const assignmentEmbed = new EmbedBuilder()
                    .setTitle('üë®‚Äçüíº Yetkili Atandƒ±')
                    .setDescription(`Tarafƒ±mƒ±zca **${assignedUser.user.username}** yetkilisi atandƒ±. Artƒ±k mesaj g√∂nderebilirsiniz.`)
                    .setColor(0x36393F)
                    .setTimestamp();

                await channel.send({ embeds: [assignmentEmbed] });

                // Kullanƒ±cƒ±ya yazma yetkisi a√ß
                await channel.permissionOverwrites.edit(userId, { 
                    ViewChannel: true, 
                    SendMessages: true, 
                    ReadMessageHistory: true 
                });

                console.log(`‚úÖ Yazma yetkisi a√ßƒ±ldƒ±: ${interaction.user.tag}`);
            } else {
                // Atanmamƒ±≈ü ticket bildirimi
                const waitingEmbed = new EmbedBuilder()
                    .setTitle('‚è≥ Yetkili Bekleniyor')
                    .setDescription('≈ûu anda online olan yetkili bulunamadƒ±. En kƒ±sa s√ºrede size yardƒ±mcƒ± olacaƒüƒ±z.')
                    .setColor(0x36393F)
                    .setTimestamp();

                await channel.send({ embeds: [waitingEmbed] });

                console.log(`‚è≥ Atanmamƒ±≈ü ticket olu≈üturuldu: ${interaction.user.tag}`);
            }

            // Log mesajƒ±
            await this.sendLogMessage(guild, {
                action: 'TICKET_OPENED',
                ticketId,
                userId,
                type,
                channelId: channel.id,
                assignedTo: assignedUserId
            }, guildConfig);

            this.addCooldown(userId);

            return {
                success: true,
                message: `‚úÖ Ticket ba≈üarƒ±yla olu≈üturuldu! <#${channel.id}>${assignedUserId ? `\nüë®‚Äçüíº Otomatik olarak <@${assignedUserId}> atandƒ±.` : ''}`,
                channelId: channel.id
            };

        } catch (error) {
            console.error('Ticket olu≈üturma hatasƒ±:', error);
            return {
                success: false,
                message: '‚ùå Ticket olu≈üturulurken bir hata olu≈ütu!'
            };
        }
    }

    // Select menu ile ticket a√ßarken: ilk ba≈üta yazma kapalƒ± ticket a√ß
    static async createTicketWithLockedChannel(interaction, type) {
        const userId = interaction.user.id;
        const guild = interaction.guild;
        const config = require('../config');
        const Ticket = require('../models/Ticket');
        const GuildConfig = require('../models/GuildConfig');
        const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');

        // MongoDB'den config verilerini al
        let guildConfig;
        try {
            const guildConfigData = await GuildConfig.getConfig(guild.id);
            if (guildConfigData) {
                guildConfig = {
                    ticketCategoryId: guildConfigData.ticketCategoryId,
                    closedCategoryId: guildConfigData.closedCategoryId,
                    logChannelId: guildConfigData.logChannelId,
                    supportRoleId: guildConfigData.supportRoleId,
                    adminRoleId: guildConfigData.adminRoleId,
                    incomingCategoryId: guildConfigData.incomingCategoryId
                };
            } else {
                guildConfig = {
                    ticketCategoryId: config.ticketCategoryId,
                    closedCategoryId: config.closedTicketCategoryId,
                    logChannelId: config.logChannelId,
                    supportRoleId: config.supportRoleId,
                    adminRoleId: config.adminRoleId,
                    incomingCategoryId: config.incomingCategoryId
                };
            }
        } catch (error) {
            console.error('Config alma hatasƒ±:', error);
            guildConfig = {
                ticketCategoryId: config.ticketCategoryId,
                closedCategoryId: config.closedTicketCategoryId,
                logChannelId: config.logChannelId,
                supportRoleId: config.supportRoleId,
                adminRoleId: config.adminRoleId,
                incomingCategoryId: config.incomingCategoryId
            };
        }

        // Cooldown ve a√ßƒ±k ticket kontrol√º
        const openTickets = await Ticket.getOpenTicketsByUser(userId);
        if (openTickets.length >= config.maxTicketsPerUser) {
            return {
                success: false,
                message: `‚ùå Zaten ${config.maxTicketsPerUser} a√ßƒ±k ticket'ƒ±nƒ±z var!`
            };
        }

        try {
            // Kategori kontrol√º - √∂nce incomingCategoryId'yi dene, yoksa ticketCategoryId'yi kullan
            let category = null;
            if (guildConfig.incomingCategoryId) {
                category = guild.channels.cache.get(guildConfig.incomingCategoryId);
            }
            if (!category && guildConfig.ticketCategoryId) {
                category = guild.channels.cache.get(guildConfig.ticketCategoryId);
            }
            if (!category) {
                return { success: false, message: '‚ùå Ticket kategorisi bulunamadƒ±! L√ºtfen √∂nce `/setup` komutunu kullanƒ±n.' };
            }

            // Otomatik atama yapƒ±lana kadar yazma kapalƒ±
            const channel = await guild.channels.create({
                name: `ticket-${interaction.user.username}`,
                type: 0,
                parent: category,
                permissionOverwrites: [
                    { id: guild.id, deny: [PermissionFlagsBits.ViewChannel] },
                    { id: userId, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ReadMessageHistory], deny: [PermissionFlagsBits.SendMessages] }, // Ticket a√ßan kullanƒ±cƒ± yazamaz
                    { id: guildConfig.supportRoleId, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.ReadMessageHistory] },
                    { id: guildConfig.adminRoleId, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.ReadMessageHistory] }
                ]
            });

            // Ticket veritabanƒ±na kaydet
            const ticketId = `TICKET-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;
            const ticket = new Ticket({
                ticketId,
                channelId: channel.id,
                userId,
                type
            });
            await ticket.save();

            // Otomatik atama (en az y√ºkl√º support)
            const supportRole = guild.roles.cache.get(guildConfig.supportRoleId);
            const adminRole = guild.roles.cache.get(guildConfig.adminRoleId);
            let assignedUser = null;
            
            if ((supportRole && supportRole.members.size > 0) || (adminRole && adminRole.members.size > 0)) {
                // √ñnce support ve admin rollerini kontrol et
                const supportMembers = supportRole ? supportRole.members : new Map();
                const adminMembers = adminRole ? adminRole.members : new Map();
                
                const availableMembers = [];
                
                // Support √ºyelerini ekle (sadece online olanlar)
                for (const [id, member] of supportMembers) {
                    // Online durumunu kontrol et
                    const presence = guild.presences.cache.get(id);
                    const isOnline = presence && (presence.status === 'online' || presence.status === 'idle' || presence.status === 'dnd');
                    
                    if (!isOnline) continue; // Offline olanlarƒ± atla
                    
                    const isAdmin = adminMembers.has(id);
                    const count = await Ticket.countDocuments({ assignedTo: id, status: 'a√ßƒ±k' });
                    availableMembers.push({
                        member,
                        workload: count,
                        isAdmin: isAdmin,
                        priority: isAdmin ? 1 : 2
                    });
                }
                
                // Sadece admin rol√ºne sahip olanlarƒ± ekle (sadece online olanlar)
                for (const [id, member] of adminMembers) {
                    if (!supportMembers.has(id)) {
                        // Online durumunu kontrol et
                        const presence = guild.presences.cache.get(id);
                        const isOnline = presence && (presence.status === 'online' || presence.status === 'idle' || presence.status === 'dnd');
                        
                        if (!isOnline) continue; // Offline olanlarƒ± atla
                        
                        const count = await Ticket.countDocuments({ assignedTo: id, status: 'a√ßƒ±k' });
                        availableMembers.push({
                            member,
                            workload: count,
                            isAdmin: true,
                            priority: 1
                        });
                    }
                }
                
                if (availableMembers.length > 0) {
                    // √ñnce √∂nceliƒüe g√∂re, sonra i≈ü y√ºk√ºne g√∂re sƒ±rala
                    availableMembers.sort((a, b) => {
                        if (a.priority !== b.priority) {
                            return a.priority - b.priority;
                        }
                        return a.workload - b.workload;
                    });
                    
                    assignedUser = availableMembers[0].member;
                }
            }

            // Embed mesajƒ± (mesajlar kapalƒ±)
            const embedFields = [
                { name: 'üë§ Kullanƒ±cƒ±', value: `<@${userId}>`, inline: true },
                { name: 'üìã Tip', value: config.ticketTypes[type].name, inline: true },
                { name: 'üìÖ Olu≈üturulma', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'üë®‚Äçüíº Atanan Yetkili', value: assignedUser ? `<@${assignedUser.id}>` : '≈ûu anda atama bekleniyor.', inline: true }
            ];
            const embed = new EmbedBuilder()
                .setTitle(`üé´ Ticket #${ticketId}`)
                .setDescription(`${config.welcomeMessages[type]}

‚ö†Ô∏è **Mesajlar kapalƒ±dƒ±r, otomatik atama bekleniyor.**`)
                .setColor(0x36393F)
                .addFields(embedFields)
                .setFooter({ text: 'Atama yapƒ±lana kadar mesaj g√∂nderemezsiniz.' });

            // Y√∂netim butonlarƒ±
            const managementButtons1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('close_ticket')
                        .setLabel('Kapat')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('üîí'),
                    new ButtonBuilder()
                        .setCustomId('transfer_ticket')
                        .setLabel('Ba≈üka Birine Aktar')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üîÑ')
                );

            await channel.send({ 
                embeds: [embed], 
                components: [managementButtons1] 
            });

            if (assignedUser) {
                // Ticket'a atananƒ± kaydet
                ticket.assignedTo = assignedUser.id;
                await ticket.save();

                // Kanal izinlerini g√ºncelle: kullanƒ±cƒ± ve atanan yetkili yazabilir
                await channel.permissionOverwrites.edit(userId, { ViewChannel: true, SendMessages: true, ReadMessageHistory: true }); // Ticket a√ßan kullanƒ±cƒ±ya yazma yetkisi ver
                await channel.permissionOverwrites.edit(assignedUser.id, { ViewChannel: true, SendMessages: true, ReadMessageHistory: true });
                await channel.permissionOverwrites.edit(guildConfig.supportRoleId, { ViewChannel: true, SendMessages: true, ReadMessageHistory: true }); // Support rol√º yazabilir
                await channel.permissionOverwrites.edit(guildConfig.adminRoleId, { ViewChannel: true, SendMessages: true, ReadMessageHistory: true }); // Admin rol√º yazabilir

                // Kanalda son 10 mesajƒ± kontrol et, ilk bulduƒüu 'üé´ Ticket #' ba≈ülƒ±klƒ± embed'i g√ºncellesin
                const messages = await channel.messages.fetch({ limit: 10 });
                const ticketMsg = messages.find(msg =>
                    msg.embeds.length > 0 &&
                    msg.embeds[0].title &&
                    msg.embeds[0].title.startsWith('üé´ Ticket #')
                );
                if (ticketMsg) {
                    const oldEmbed = ticketMsg.embeds[0];
                    // Fields'ƒ± g√ºncelle
                    const newFields = oldEmbed.fields.map(f =>
                        f.name === 'üë®‚Äçüíº Atanan Yetkili'
                            ? { name: f.name, value: `<@${assignedUser.id}>`, inline: true }
                            : f
                    );
                    const newEmbed = EmbedBuilder.from(oldEmbed).setFields(newFields);
                    await ticketMsg.edit({ embeds: [newEmbed] });
                }

                // Atama bildirimi
                const assignedEmbed = new EmbedBuilder()
                    .setTitle('üë®‚Äçüíº Yetkili Atandƒ±')
                    .setDescription(`Tarafƒ±mƒ±zca **${assignedUser.user.username}** yetkilisi atandƒ±. Artƒ±k mesaj g√∂nderebilirsiniz.`)
                    .setColor(0x36393F)
                    .setTimestamp();
                
                console.log(`üì® "Yetkili Atandƒ±" mesajƒ± g√∂nderiliyor...`);
                await channel.send({ embeds: [assignedEmbed] });
                console.log(`‚úÖ "Yetkili Atandƒ±" mesajƒ± ba≈üarƒ±yla g√∂nderildi!`);
            } else {
                // Atanmamƒ±≈ü ticket bildirimi - ticket kanalƒ±ndaki embed'ƒ±n altƒ±na ekle
                const waitingEmbed = new EmbedBuilder()
                    .setTitle('‚è≥ Yetkili Bekleniyor')
                    .setDescription(`Merhaba <@${userId}>! Ticket'ƒ±nƒ±z ba≈üarƒ±yla olu≈üturuldu.\n\n**Durum:** ≈ûu anda online olan yetkili bulunamadƒ±.\n**Tahmini S√ºre:** En kƒ±sa s√ºrede size yardƒ±mcƒ± olacaƒüƒ±z.\n\n**L√ºtfen bekleyiniz...**`)
                    .setColor(0x36393F)
                    .setTimestamp()
                    .setFooter({ text: 'Destek ekibimiz en kƒ±sa s√ºrede sizinle ilgilenecek' });

                // Ticket kanalƒ±na g√∂nder (embed'ƒ±n altƒ±na eklenir)
                await channel.send({ embeds: [waitingEmbed] });
            }

            return {
                success: true,
                message: `‚úÖ Ticket ba≈üarƒ±yla a√ßƒ±ldƒ±! <#${channel.id}>`
            };
        } catch (error) {
            console.error('Ticket a√ßƒ±lƒ±rken hata:', error);
            return { success: false, message: '‚ùå Ticket a√ßƒ±lƒ±rken bir hata olu≈ütu!' };
        }
    }

    // Ticket kapatma - sadece atanan ki≈üi veya admin kapatabilir
    async closeTicket(interaction) {
        const channel = interaction.channel;
        const ticket = await Ticket.findOne({ channelId: channel.id });

        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Bu kanal bir ticket deƒüil!'
            };
        }

        if (ticket.status === 'kapalƒ±') {
            return {
                success: false,
                message: '‚ùå Bu ticket zaten kapalƒ±!'
            };
        }

        // MongoDB'den config verilerini al
        const guildConfig = await this.getGuildConfig(interaction.guild.id);

        // Yetki kontrol√º - sadece atanan ki≈üi veya admin kapatabilir
        const isAdmin = interaction.member.roles.cache.has(guildConfig.adminRoleId) ||
                       interaction.member.permissions.has(PermissionFlagsBits.ManageGuild);
        
        const isAssigned = ticket.assignedTo === interaction.user.id;
        const isTicketCreator = ticket.userId === interaction.user.id;

        if (!isAdmin && !isAssigned && !isTicketCreator) {
            return {
                success: false,
                message: '‚ùå Bu ticket\'ƒ± sadece atanan yetkili, ticket sahibi veya admin kapatabilir!'
            };
        }

        try {
            // Ticket durumunu g√ºncelle
            ticket.status = 'kapalƒ±';
            ticket.closedAt = new Date();
            ticket.closedBy = interaction.user.id;
            await ticket.save();

            // Transkript olu≈ütur
            const transcript = await this.createTranscript(channel, ticket);

            // "üìÅ Kapalƒ± Ticketlar" kategorisini al
            const closedCategory = interaction.guild.channels.cache.get(guildConfig.closedCategoryId);
            if (closedCategory) {
                try {
                    // T√úM KANALLARDA aynƒ± ticket ID'sine sahip transkript kanalƒ± ara (case-insensitive)
                    let existingTranscriptChannel = null;
                    
                    // √ñnce transkript- ile ba≈ülayan kanallarƒ± ara
                    const allChannels = interaction.guild.channels.cache.filter(ch => 
                        ch.type === 0 && 
                        ch.name.toLowerCase().startsWith('transkript-') &&
                        ch.name.toLowerCase().includes(ticket.ticketId.toLowerCase())
                    );
                    
                    if (allChannels.size > 0) {
                        existingTranscriptChannel = allChannels.first();
                        console.log(`‚úÖ Mevcut transkript kanalƒ± bulundu: #${existingTranscriptChannel.name}`);
                    }
                    
                    // Eƒüer transkript- ile ba≈ülayan bulunamazsa, sadece ticket ID'sini ara
                    if (!existingTranscriptChannel) {
                        const ticketIdChannels = interaction.guild.channels.cache.filter(ch => 
                            ch.type === 0 && 
                            ch.name.toLowerCase().includes(ticket.ticketId.toLowerCase()) &&
                            ch.name.toLowerCase().includes('transkript')
                        );
                        
                        if (ticketIdChannels.size > 0) {
                            existingTranscriptChannel = ticketIdChannels.first();
                            console.log(`‚úÖ Ticket ID ile transkript kanalƒ± bulundu: #${existingTranscriptChannel.name}`);
                        }
                    }
                    
                    let transcriptChannel;
                    if (existingTranscriptChannel) {
                        // Mevcut kanalƒ± kullan
                        transcriptChannel = existingTranscriptChannel;
                        console.log(`‚úÖ Mevcut transkript kanalƒ± kullanƒ±lƒ±yor: #${transcriptChannel.name}`);
                    } else {
                        // Yeni transkript kanalƒ± olu≈ütur
                        transcriptChannel = await interaction.guild.channels.create({
                            name: `transkript-${ticket.ticketId}`,
                        type: 0, // Text channel
                            parent: closedCategory.id,
                        permissionOverwrites: [
                            {
                                id: interaction.guild.id,
                                deny: [PermissionFlagsBits.ViewChannel]
                            },
                            {
                                    id: guildConfig.supportRoleId,
                                    allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ReadMessageHistory],
                                    deny: [PermissionFlagsBits.SendMessages]
                            },
                            {
                                    id: guildConfig.adminRoleId,
                                    allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ReadMessageHistory],
                                    deny: [PermissionFlagsBits.SendMessages]
                            }
                        ]
                    });
                        console.log(`‚úÖ Yeni transkript kanalƒ± olu≈üturuldu: #${transcriptChannel.name}`);
                    }

                    // Transkript embed'i yeni kanalda g√∂nder
                    const transcriptEmbed = new EmbedBuilder()
                        .setTitle(`üìÑ Ticket Transkripti - #${ticket.ticketId}`)
                        .setDescription(`Bu ticket ${interaction.user} tarafƒ±ndan kapatƒ±ldƒ±.`)
                        .addFields(
                            { name: 'üë§ Kullanƒ±cƒ±', value: `<@${ticket.userId}>`, inline: true },
                            { name: 'üìã Tip', value: config.ticketTypes[ticket.type].name, inline: true },
                            { name: 'üë®‚Äçüíº Atanan', value: ticket.assignedTo ? `<@${ticket.assignedTo}>` : 'Atanmamƒ±≈ü', inline: true },
                            { name: 'üìÖ Olu≈üturulma', value: `<t:${Math.floor(ticket.createdAt.getTime() / 1000)}:F>`, inline: true },
                            { name: 'üîí Kapatƒ±lma', value: `<t:${Math.floor(ticket.closedAt.getTime() / 1000)}:F>`, inline: true },
                            { name: 'üîß Kapatan', value: `<@${ticket.closedBy}>`, inline: true }
                        )
                        .setColor(0x36393F)
                        .setTimestamp();

                    // √á√∂z√ºld√º ve Yeniden A√ß butonlarƒ±
                    const actionRow = new ActionRowBuilder().addComponents(
                        new ButtonBuilder()
                            .setCustomId('resolve_ticket')
                            .setLabel('√á√∂z√ºld√º')
                            .setStyle(ButtonStyle.Success)
                            .setEmoji('‚úÖ'),
                        new ButtonBuilder()
                            .setCustomId('reopen_ticket')
                            .setLabel('Yeniden A√ß')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('üîÑ')
                    );

                    // Transkript'i dosya olarak g√∂nder
                    const transcriptPath = `./transcript-${ticket.ticketId}.txt`;
                    fs.writeFileSync(transcriptPath, transcript);
                    
                    await transcriptChannel.send({ 
                        embeds: [transcriptEmbed], 
                        files: [transcriptPath],
                        components: [actionRow]
                    });

                    // Dosyayƒ± sil
                    fs.unlinkSync(transcriptPath);

                    console.log(`‚úÖ Transkript kanalƒ± olu≈üturuldu: #${transcriptChannel.name}`);

                    // Eski ticket kanalƒ±nƒ± sil
                    await channel.delete();
                    console.log(`üóëÔ∏è Eski ticket kanalƒ± silindi: #${channel.name}`);

                } catch (error) {
                    console.error('Transkript kanalƒ± olu≈üturma hatasƒ±:', error);
                    // Hata durumunda eski kanalƒ± silmeye devam et
                    await channel.delete();
                }
            } else {
                console.log('‚ö†Ô∏è Kapalƒ± ticket kategorisi bulunamadƒ±, sadece kanal siliniyor.');
                await channel.delete();
            }

            // MongoDB'den ticket verisini sil
            // Ticket verisi silinmiyor, status 'kapalƒ±' olarak kalƒ±yor
            console.log(`‚ÑπÔ∏è Ticket verisi ar≈üivde tutuluyor: ${ticket.ticketId}`);

            // Ba≈üarƒ± mesajƒ±nƒ± d√∂nd√ºr
            const result = {
                success: true,
                message: `‚úÖ Ticket #${ticket.ticketId} ba≈üarƒ±yla kapatƒ±ldƒ±!`
            };

            return result;

        } catch (error) {
            console.error('Ticket kapatma hatasƒ±:', error);
            return {
                success: false,
                message: '‚ùå Ticket kapatƒ±lƒ±rken bir hata olu≈ütu!'
            };
        }
    }

    // Ticket atama
    async assignTicket(interaction, targetUser) {
        const channel = interaction.channel;
        const ticket = await Ticket.findOne({ channelId: channel.id });

        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Bu kanal bir ticket deƒüil!'
            };
        }

        // Eƒüer kendine atƒ±yorsa "devre alma", ba≈ükasƒ±na atƒ±yorsa "transfer" mesajƒ±
        const isSelfAssignment = targetUser.id === interaction.user.id;
        const actionType = isSelfAssignment ? 'devre alƒ±ndƒ±' : 'transfer edildi';

        try {
            ticket.assignedTo = targetUser.id;
            await ticket.save();

            // Kanalda son 10 mesajƒ± kontrol et, ilk bulduƒüu "üé´ Ticket #..." ba≈ülƒ±klƒ± embed'i g√ºncellesin
            const messages = await channel.messages.fetch({ limit: 10 });
            const ticketMsg = messages.find(msg =>
                msg.embeds.length > 0 &&
                msg.embeds[0].title &&
                msg.embeds[0].title.startsWith('üé´ Ticket #')
            );
            if (ticketMsg) {
                const oldEmbed = ticketMsg.embeds[0];
                // Fields'ƒ± g√ºncelle
                const newFields = oldEmbed.fields.map(f =>
                    f.name === 'üë®‚Äçüíº Atanan Yetkili'
                        ? { name: f.name, value: `<@${targetUser.id}>`, inline: true }
                        : f
                );
                const newEmbed = EmbedBuilder.from(oldEmbed).setFields(newFields);
                await ticketMsg.edit({ embeds: [newEmbed] });
            }

            return {
                success: true,
                message: `‚úÖ Ticket ba≈üarƒ±yla ${actionType}!`
            };

        } catch (error) {
            console.error('Ticket atama hatasƒ±:', error);
            return {
                success: false,
                message: `‚ùå Ticket ${actionType} sƒ±rasƒ±nda bir hata olu≈ütu!`
            };
        }
    }

    // Ticket √ß√∂z√ºld√º olarak i≈üaretleme
    async resolveTicket(interaction) {
        const channel = interaction.channel;
        const ticket = await Ticket.findOne({ channelId: channel.id });

        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Bu kanal bir ticket deƒüil!'
            };
        }

        if (ticket.status === '√ß√∂z√ºld√º') {
            return {
                success: false,
                message: '‚ùå Bu ticket zaten √ß√∂z√ºld√º olarak i≈üaretlenmi≈ü!'
            };
        }

        // Sadece ticket'ƒ± atanan ki≈üi √ß√∂zebilir
        if (ticket.assignedTo !== interaction.user.id) {
            return {
                success: false,
                message: '‚ùå Bu butonu sadece ticket\'ƒ± atanan yetkili kullanabilir!'
            };
        }

        // MongoDB'den config verilerini al
        const guildConfig = await this.getGuildConfig(interaction.guild.id);

        try {
            ticket.status = '√ß√∂z√ºld√º';
            ticket.resolvedAt = new Date();
            ticket.resolvedBy = interaction.user.id;
            await ticket.save();

            const embed = new EmbedBuilder()
                .setTitle('‚úÖ Ticket √á√∂z√ºld√º')
                .setDescription(`Bu ticket ${interaction.user} tarafƒ±ndan √ß√∂z√ºld√º olarak i≈üaretlendi.\n\n**Ticket Detaylarƒ±:**\n‚Ä¢ **Ticket ID:** ${ticket.ticketId}\n‚Ä¢ **Kullanƒ±cƒ±:** <@${ticket.userId}>\n‚Ä¢ **√á√∂zen:** <@${interaction.user.id}>\n‚Ä¢ **√á√∂z√ºlme Tarihi:** <t:${Math.floor(Date.now() / 1000)}:F>`)
                .setColor(0x00FF00)
                .setTimestamp()
                .setFooter({ text: 'Ticket ba≈üarƒ±yla √ß√∂z√ºld√º' });

            await channel.send({ embeds: [embed] });

            // Log mesajƒ±
            await this.sendLogMessage(interaction.guild, {
                action: 'TICKET_RESOLVED',
                ticketId: ticket.ticketId,
                userId: ticket.userId,
                resolvedBy: interaction.user.id
            }, guildConfig);

            return {
                success: true,
                message: `‚úÖ Ticket #${ticket.ticketId} ba≈üarƒ±yla √ß√∂z√ºld√º olarak i≈üaretlendi!`
            };

        } catch (error) {
            console.error('Ticket √ß√∂zme hatasƒ±:', error);
            return {
                success: false,
                message: '‚ùå Ticket √ß√∂z√ºl√ºrken bir hata olu≈ütu!'
            };
        }
    }

    // Ticket yeniden a√ßma
    async reopenTicket(interaction) {
        const channel = interaction.channel;
        const ticket = await Ticket.findOne({ channelId: channel.id });

        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Bu kanal bir ticket deƒüil!'
            };
        }

        if (ticket.status === 'a√ßƒ±k') {
            return {
                success: false,
                message: '‚ùå Bu ticket zaten a√ßƒ±k!'
            };
        }

        // MongoDB'den config verilerini al
        const guildConfig = await this.getGuildConfig(interaction.guild.id);

        try {
            ticket.status = 'a√ßƒ±k';
            ticket.closedAt = null;
            ticket.closedBy = null;
            await ticket.save();

            const embed = new EmbedBuilder()
                .setTitle('üîÑ Ticket Yeniden A√ßƒ±ldƒ±')
                .setDescription(`Bu ticket ${interaction.user} tarafƒ±ndan yeniden a√ßƒ±ldƒ±.`)
                .setColor(0x36393F)
                .setTimestamp();

            await channel.send({ embeds: [embed] });

            // Log mesajƒ±
            await this.sendLogMessage(interaction.guild, {
                action: 'TICKET_REOPENED',
                ticketId: ticket.ticketId,
                userId: ticket.userId,
                reopenedBy: interaction.user.id
            }, guildConfig);

            return {
                success: true,
                message: `‚úÖ Ticket #${ticket.ticketId} yeniden a√ßƒ±ldƒ±!`
            };

        } catch (error) {
            console.error('Ticket yeniden a√ßma hatasƒ±:', error);
            return {
                success: false,
                message: '‚ùå Ticket yeniden a√ßƒ±lƒ±rken bir hata olu≈ütu!'
            };
        }
    }

    // Transkript olu≈üturma
    async createTranscript(channel, ticket) {
        try {
            const messages = await channel.messages.fetch({ limit: 100 });
            let transcript = `=== TICKET TRANSCRIPT ===\n`;
            transcript += `Ticket ID: ${ticket.ticketId}\n`;
            transcript += `Kullanƒ±cƒ±: ${ticket.userId}\n`;
            transcript += `Tip: ${ticket.type}\n`;
            transcript += `Atanan: ${ticket.assignedTo || 'Atanmamƒ±≈ü'}\n`;
            transcript += `Olu≈üturulma: ${ticket.createdAt}\n`;
            transcript += `Kapatƒ±lma: ${ticket.closedAt}\n`;
            transcript += `Kapatan: ${ticket.closedBy}\n`;
            transcript += `========================\n\n`;

            messages.reverse().forEach(msg => {
                const timestamp = new Date(msg.createdTimestamp).toLocaleString('tr-TR');
                transcript += `[${timestamp}] ${msg.author.username}: ${msg.content}\n`;
            });

            return transcript;

        } catch (error) {
            console.error('Transkript olu≈üturma hatasƒ±:', error);
            return 'Transkript olu≈üturulamadƒ±.';
        }
    }

    // Log mesajƒ± g√∂nderme
    async sendLogMessage(guild, data, guildConfig) {
        try {
            // Log kanalƒ± ID kontrol√º
            if (!guildConfig.logChannelId) {
                console.log('‚ö†Ô∏è Log kanalƒ± ID tanƒ±mlanmamƒ±≈ü, log mesajƒ± g√∂nderilmedi.');
                return;
            }

            const logChannel = guild.channels.cache.get(guildConfig.logChannelId);
            if (!logChannel) {
                console.log(`‚ö†Ô∏è Log kanalƒ± bulunamadƒ± (ID: ${guildConfig.logChannelId}), log mesajƒ± g√∂nderilmedi.`);
                return;
            }

            // Kanal tipi kontrol√º
            if (!logChannel.isTextBased()) {
                console.log('‚ö†Ô∏è Log kanalƒ± metin kanalƒ± deƒüil, log mesajƒ± g√∂nderilmedi.');
                return;
            }

            const embed = new EmbedBuilder()
                .setTimestamp();

            switch (data.action) {
                case 'TICKET_OPENED':
                    embed.setTitle('üé´ Yeni Ticket A√ßƒ±ldƒ±')
                        .setColor(0x36393F)
                        .setDescription(`**Ticket ID:** ${data.ticketId}\n**Kullanƒ±cƒ±:** <@${data.userId}>\n**Tip:** ${config.ticketTypes[data.type].name}\n**Kanal:** <#${data.channelId}>`);
                    
                    if (data.assignedTo) {
                        embed.addFields({ name: 'üë®‚Äçüíº Atanan Yetkili', value: `<@${data.assignedTo}>`, inline: true });
                    }
                    break;

                case 'TICKET_CLOSED':
                    embed.setTitle('üîí Ticket Kapatƒ±ldƒ±')
                        .setColor(0x36393F)
                        .setDescription(`**Ticket ID:** ${data.ticketId}\n**Kullanƒ±cƒ±:** <@${data.userId}>\n**Kapatan:** <@${data.closedBy}>${data.transcriptChannelId ? `\n\nüìÑ **Transkript kanalƒ±:** <#${data.transcriptChannelId}>` : ''}`);
                    break;

                case 'TICKET_RESOLVED':
                    embed.setTitle('‚úÖ Ticket √á√∂z√ºld√º')
                        .setColor(0x00FF00)
                        .setDescription(`**Ticket ID:** ${data.ticketId}\n**Kullanƒ±cƒ±:** <@${data.userId}>\n**√á√∂zen:** <@${data.resolvedBy}>\n**Durum:** ‚úÖ Ba≈üarƒ±yla √ß√∂z√ºld√º`);
                    break;

                case 'TICKET_REOPENED':
                    embed.setTitle('üîÑ Ticket Yeniden A√ßƒ±ldƒ±')
                        .setColor(0x36393F)
                        .setDescription(`**Ticket ID:** ${data.ticketId}\n**Kullanƒ±cƒ±:** <@${data.userId}>\n**Yeniden A√ßan:** <@${data.reopenedBy}>`);
                    break;
            }

            await logChannel.send({ embeds: [embed] });

        } catch (error) {
            console.error('Log mesajƒ± g√∂nderme hatasƒ±:', error);
            // Log hatasƒ± bot'u durdurmaz, sadece konsola yazdƒ±r
        }
    }

    // ƒ∞statistik alma
    async getStats() {
        try {
            const stats = await Ticket.getTicketStats();
            return stats[0] || { totalTickets: 0, openTickets: 0, closedTickets: 0, resolvedTickets: 0 };
        } catch (error) {
            console.error('ƒ∞statistik alma hatasƒ±:', error);
            return { totalTickets: 0, openTickets: 0, closedTickets: 0, resolvedTickets: 0 };
        }
    }

    // Detaylƒ± istatistik alma
    async getDetailedStats() {
        try {
            // Temel istatistikler
            const basicStats = await this.getStats();
            
            // En √ßok ticket a√ßan kullanƒ±cƒ±lar (Top 3)
            const topOpeners = await Ticket.aggregate([
                { $group: { _id: '$userId', count: { $sum: 1 } } },
                { $sort: { count: -1 } },
                { $limit: 3 }
            ]);

            // En √ßok ticket √ß√∂zen yetkililer (Top 3) - resolvedBy alanƒ±nƒ± kullan
            const topResolvers = await Ticket.aggregate([
                { $match: { status: '√ß√∂z√ºld√º', resolvedBy: { $exists: true, $ne: null } } },
                { $group: { _id: '$resolvedBy', count: { $sum: 1 } } },
                { $sort: { count: -1 } },
                { $limit: 3 }
            ]);

            // Ticket t√ºrlerine g√∂re daƒüƒ±lƒ±m
            const ticketsByType = await Ticket.aggregate([
                { $group: { _id: '$type', count: { $sum: 1 } } },
                { $sort: { count: -1 } }
            ]);

            // Ortalama kapatma s√ºresi (saat cinsinden)
            const avgCloseTime = await Ticket.aggregate([
                { $match: { closedAt: { $exists: true } } },
                { 
                    $addFields: { 
                        closeTimeHours: { 
                            $divide: [
                                { $subtract: ['$closedAt', '$createdAt'] },
                                3600000 // milisaniye -> saat
                            ]
                        }
                    }
                },
                { $group: { _id: null, avgHours: { $avg: '$closeTimeHours' } } }
            ]);

            // Son 3 a√ßƒ±lan ticket
            const recentTickets = await Ticket.find()
                .sort({ createdAt: -1 })
                .limit(3)
                .populate('userId', 'username');

            // Son 3 √ß√∂z√ºlen ticket
            const resolvedTickets = await Ticket.find({ 
                status: '√ß√∂z√ºld√º', 
                resolvedBy: { $exists: true, $ne: null } 
            })
                .sort({ resolvedAt: -1 })
                .limit(3);

            // G√ºnl√ºk istatistikler (son 7 g√ºn)
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            
            const dailyStats = await Ticket.aggregate([
                { $match: { createdAt: { $gte: sevenDaysAgo } } },
                {
                    $group: {
                        _id: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },
                        count: { $sum: 1 }
                    }
                },
                { $sort: { _id: -1 } }
            ]);

            return {
                basic: basicStats,
                topOpeners,
                topResolvers,
                ticketsByType,
                avgCloseTime: avgCloseTime[0]?.avgHours || 0,
                recentTickets,
                resolvedTickets,
                dailyStats
            };

        } catch (error) {
            console.error('Detaylƒ± istatistik alma hatasƒ±:', error);
            return {
                basic: { totalTickets: 0, openTickets: 0, closedTickets: 0, resolvedTickets: 0 },
                topOpeners: [],
                topResolvers: [],
                ticketsByType: [],
                avgCloseTime: 0,
                recentTickets: [],
                resolvedTickets: [],
                dailyStats: []
            };
        }
    }
}

module.exports = TicketManager; 